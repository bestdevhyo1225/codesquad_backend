# 1 - 5 정리 

## Require

### Node.js 의 모듈 로딩 시스템
    
    - Node.js 에서 파일과 모듈은 1대1 대응
    - 각 파일은 별도의 모듈로 처리 된다.
    - 여러곳에서 하나의 파일에 작성된 모듈을 필요로 할때 동일한 인스턴스를 사용할 수 있도록 한다.
        즉, 모듈을 require할 때마다 새로운 인스턴스가 생성되는 것이 아니라 '캐싱된 객체 인스턴스를 재사용' 하는 것이다.
    
    - 한번 로딩(require)된 모듈은 'require.cache' 라는 객체에 캐싱 된다.
    - key 값으로 '해당 모듈 파일의 경로' 를 갖게 된다.
        key 값이 삭제 된다면 다음 require 요청시 재로딩 하게 된다.
        
### require 가 갖는 문제점
 
    - 캐싱된 모듈을 사용하기 때문에 불 필요한 메모리 사용을 피할 수 있다.
    - 한번 로딩된 후 재사용되기 때문에 싱글톤과 같이 동작한다고도 생각할 수 있다.
    - 그러나 모듈 캐싱 방식이 다음과 같이 제대로 동작하지 않는 경우가 있다.
        1) 파일 이름이 잘못된 대 / 소문자 사용
        2) 다른 모듈이 NPM 에서 동일한 모듈을 설치할 때
        
### 대 / 소문자 구분

    - windows 및 macOS 는 기본적으로 파일 시스템에서 대 / 소문자를 구분하지 않는다.
        * foo.js 와 FOO.js 는 동일한 파일
        
    - Node.js 에서는 대 / 소문자를 구분하기 때문에 파일 이름을 두 개의 개별 모듈로 취급
        * foo.js 와 FOO.js 는 같은 파일인지 구분하지 못함
    
    - require 시 대 / 소문자를 구분해 key 로 사용하고 있기 때문에 2개의 객체가 생성되었으나,
      결과적으로 파일 시스템에 도달하면 같은 파일이 2번 반환된 것이다.
      같은 파일에 서로 다른 모듈로 2개가 생성되어 있는것이다.

## Exports

### exports 과 module.exports 의 관계
 
    - exports 가 call by reference 로 module.exports 를 바라 보고 있다.
    - 리턴되는 값은 항상 call by reference 이다.
    - 코드 관계로 표현 
        var module = { 
            exports: {}, 
        }
        
        var exports = module.exports;
        
        return module.exports
        
    - 기본적으로 exports 와 module.exports 는 모두 하나의 객체를 바라보고 있다.
    - 최종적으로 return 되는것은 module.exports
    - exports 를 멤버에 추가하면 module.exports 에 같은 멤버도 추가 되는 것
      
## Compiler / Interpreter
    
    - 컴파일 언어와 인터프리터 언어의 가장 큰 차이점 '컴파일 시점' 이다.
        * 런타임 전에 컴파일을 하는지 안하는지
        
    - 컴파일러 (Complier) : 컴퓨터가 직접 이해할 수 있는 언어로 바꿔주는 일을 한다. ( 소스 프로그램을 '한 번에' 기계어로 변환 )
                          장) 번역 시간이 오래걸리지만, 한 번 번역한 후에는 다시 번역하지 않으므로 실행 속도가 빠르다.
                          단) 번역과 실행 과정을 거처야 하기 때문에 번역과정이 번거로움..
                          
                          
    - 인터프리터 (Interpreter) : 컴파일러와 달리 프로그램을 '한 단계씩' 기계어로 해석하여 실행하는 '언어처리 프로그램'입니다.
                              장) 줄 단위로 변역, 실행 되기 때문에 시분할 시스템에 유용하다.
                                 원시 프로그램의 변화에 대한 반응이 빠르다.
                                 한 단계씩 테스트와 수정을 하면서 진행시켜 나가는 대화형 언어에 적합.
                              단) 실행 시간이 길어 속도가 늦다는 단점


## Debugging

    - breakpoints : 프로그램을 실행하는 도중에 유저가 필요한 시점에서 프로그램을 일시 정지 시키는 역할
        * Conditional Expression (조건 표현식) -> 어떤 조건에서 디버깅 화면으로 전환할지 쓰면 된다. 현재 조건이 true 일 때마다 중단점에 도달한다.
        * Hit Count (조회수) -> '조회수'는 실행을 '중단'하기 전에 중단 점에 도달해야하는 횟수를 제어한다.
     
    - watch : 내가 보고 싶은 데이터를 감시할 수 있다. 특정한 조건에만 중단점에 도달할 수 있도록 한다.
    
    - call stack : '호출 스택'이란 프로그램에서 우리가 어디에 있는지를 기본적으로 기록하는 데이터 구조
                    1) 함수를 실행 한다.
                    2) 함수의 기록을 stack 에 맨 위에 Push 한다.
                    3) 함수의 결과를 반환하면 stack 에 있던 함수는 Pop 이 된다. 
    
    - step over : 현재 중단된 지점에서 함수가 존재해도 무시하고 '다음 라인'으로 이동 한다.
    
    - step into : 현재 중단된 지점에서 함수가 존재 한다면 '호출한 곳'으로 이동한 후 함수의 진행 상황을 볼 수 있도록 한다.
                  하나의 명령문만 실행되도록 보장하므로 일반적인 '한 번에 한줄씩' 작업으로 사용합니다.
    
    - step out : 현재 중단된 지점에서 현재 함수의 나머지 부분을 실행한 다음 함수 호출 뒤 다음 명령문에서 일시 중지 한다.
